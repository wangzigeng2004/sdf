module generation/injections/to-injections

imports
  libstratego-lib
  libstrc
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-  
  generation/gen-utils/to-str
  analysis/desugar
  generation/signatures/to-statix-sig

imports
  signatures/aliases/-
  signatures/aterms/-
  signatures/basic/-
  signatures/characterclass/-
  signatures/constants/-
  signatures/grammar/-
  signatures/kernel/-
  signatures/labels/-
  signatures/layout/-
  signatures/layout-constraints/-
  signatures/lifting/-
  signatures/literals/-
  signatures/modules/-
  signatures/priority/-
  signatures/regular/-
  signatures/renaming/-
  signatures/restrictions/-
  signatures/sdf2-core/-
  signatures/sorts/-
  signatures/symbols/-
  signatures/TemplateLang-sig
  
rules
  language-spec-name = prim("pp_language_spec_name") <+ !"unknown"

rules

  // str-generate-signatures :: SDF3.Module -> Stratego.Module
  str-generate-injections = strip-annos; str-module-to-injections

  str-module-to-injections:
    Module(modname, imports, sections) -> Module(modname', [
	  imports0,
	  imports1*,
	  Signature([Constructors(signatures)]),
	  Rules(explication-rules),
	  Rules(placeholder-rules),
	  Rules(sort-strategies)
    ])
  with modname'  := <to-str-module-name(|"-injections", "injections")> Module(modname)
     ; lang := <language-spec-name>
     ; imports0  := Imports([
     	Import(<to-str-module-name(|"-sig","signatures")> Module(modname)),
     	Import(<to-str-module-name(|"-pp","pp")> Module(modname))
       ])
     ; imports1*  := <map(to-str-import(|"-injections", "injections"))> imports
     ; signatures := <filter(str-section-to-inj-sigs); flatten-list-once> sections
     ; cfsorts := <filter(not(?SDFSection(LexicalSyntax(_)))); collect-all(stx-collect-sorts)> sections
     ; sort-strategies := <map(str-sort-to-strategy(|lang))> cfsorts
     ; explication-rules := <filter(str-section-to-explication-rules(|lang)); flatten-list-once> sections
     ; placeholder-rules := <map(str-sort-to-placeholder-rules(|lang))> cfsorts
     
rules

  // str-section-to-inj-sigs :: SDF3.Section -> [Stratego.?]

  str-section-to-inj-sigs:
    SDFSection(ContextFreeSyntax(productions)) -> signatures
  with signatures := <filter(str-cfg-production-to-inj-sig <+ str-cfg-template-to-inj-sig)> productions

  str-section-to-inj-sigs:
    TemplateSection(templates) -> signatures
  with signatures := <filter(str-cfg-template-to-inj-sig)> templates

  str-section-to-inj-sigs:
    SDFSection(Kernel(productions)) -> signatures
  with signatures := <filter(str-cfg-production-to-inj-sig)> productions


  // str-cfg-production-to-inj-sig :: SDF3.SdfProduction -> Stratego.?

  str-cfg-production-to-inj-sig:
    SdfProduction(SortDef(sortname), Rhs(body), Attrs(attrs))
    -> <str-inj-to-sig> (sortname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-production-to-inj-sig:
    SdfProduction(Cf(SortDef(sortname)), Rhs(body), Attrs(attrs))
    -> <str-inj-to-sig> (sortname, body)
  where <not(stx-ignore-production)> attrs

  // str-cfg-template-to-inj-sig :: SDF3.TemplateProduction -> Stratego.?

  str-cfg-template-to-inj-sig:
    TemplateProduction(SortDef(sortname), body, Attrs(attrs))
    -> <str-inj-to-sig> (sortname, body)
  where <not(stx-ignore-production)> attrs

  // str-inj-to-sig :: (SDF3.Sort, SDF3.RHS + SDF3.Template) -> Stratego.?
  str-inj-to-sig: (sortname, body) -> OpDecl(consname, FunType(body', ConstType(SortNoArgs(sortname))))
  with body' := <collect-om-concat(stx-cfg-sort-to-sig)> body
     ; consname := <stx-generate-injection-name> (sortname, <collect-all-concat(is-string)> body')

  // str-cfg-sort-to-sig :: SDF3.SortSymbol -> Stratego.?
  str-cfg-sort-to-sig:
    Sort(name) -> ConstType(SortNoArgs(name))
  str-cfg-sort-to-sig:
    IterStarSep(sort, _) -> ConstType(Sort("List", [<str-cfg-sort-to-sig> sort]))
  
rules

  str-sort-to-strategy(|lang):
    sortname -> SDefNoArgs($[explicate-injections-[lang]], CallNoArgs(SVar($[explicate-injections-[lang]-[sortname]])))

rules

  // str-section-to-explication-rules :: SDF3.Section -> [Stratego.?]

  str-section-to-explication-rules(|lang):
    SDFSection(ContextFreeSyntax(productions)) -> signatures
  with signatures := <filter(str-cfg-production-to-explication-rule(|lang) <+ str-cfg-template-to-explication-rule(|lang))> productions

  str-section-to-explication-rules(|lang):
    TemplateSection(templates) -> signatures
  with signatures := <filter(str-cfg-template-to-explication-rule(|lang))> templates

  str-section-to-explication-rules(|lang):
    SDFSection(Kernel(productions)) -> signatures
  with signatures := <filter(str-cfg-production-to-explication-rule(|lang))> productions


  // stx-cfg-production-to-explication-rule :: SDF3.SdfProduction -> Stratego.?

  str-cfg-production-to-explication-rule(|lang):
    SdfProduction(SortDef(sortname), Rhs(body), Attrs(attrs))
    -> <str-inj-to-explication-rule(|lang)> (sortname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-production-to-explication-rule(|lang):
    SdfProduction(Cf(SortDef(sortname)), Rhs(body), Attrs(attrs))
    -> <str-inj-to-explication-rule(|lang)> (sortname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-production-to-explication-rule(|lang):
    SdfProductionWithCons(SortCons(SortDef(sortname), Constructor(consname)), body, Attrs(attrs))
    -> <str-cons-to-explication-rule(|lang)> (sortname, consname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-production-to-explication-rule(|lang):
    SdfProductionWithCons(SortCons(Cf(SortDef(sortname)), Constructor(consname)), body, Attrs(attrs))
    -> <str-cons-to-explication-rule(|lang)> (sortname, consname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-production-to-explication-rule(|lang):
    SdfProductionWithCons(SortCons(Lex(SortDef(sortname)), Constructor(consname)), body, Attrs(attrs))
    -> <str-cons-to-explication-rule(|lang)> (sortname, consname, body)
  where <not(stx-ignore-production)> attrs



  // str-cfg-template-to-cons-sig :: SDF3.TemplateProduction -> Stratego.?

  str-cfg-template-to-explication-rule(|lang):
    TemplateProductionWithCons(SortCons(SortDef(sortname), Constructor(consname)), body, Attrs(attrs))
    -> <str-cons-to-explication-rule(|lang)> (sortname, consname, body)
  where <not(stx-ignore-production)> attrs

  str-cfg-template-to-explication-rule(|lang):
    TemplateProduction(SortDef(sortname), body, Attrs(attrs))
    -> <str-inj-to-explication-rule(|lang)> (sortname, body)
  where <not(stx-ignore-production)> attrs


  // str-inj-to-explication-rule :: (SDF3.Sort, SDF3.RHS + SDF3.Template) -> Stratego.?
  str-inj-to-explication-rule(|lang): (sortname, body@Sort(tosortname))
  -> RDefNoArgs($[explicate-injections-[lang]-[sortname]], Rule(
            Var("t")
          , NoAnnoList(
              Op(
                consname
              , [App(CallNoArgs(SVar($[explicate-injections-[lang]-[tosortname]])), Var("t"))]
              )
            )
          , BA(CallNoArgs(SVar($[is-[lang]-[tosortname]])), Var("t"))
          )
        )
  with consname := <stx-generate-injection-name> (sortname, <collect-om-concat(stx-cfg-sort-to-sig; is-string)> body)


  // str-cons-to-explication-rule :: (SDF3.Sort, SDF3.IdCon, SDF3.RHS + SDF3.Template) -> Stratego.?
  str-cons-to-explication-rule(|lang): (sortname, consname, body)
  -> RDefNoArgs($[explicate-injections-[lang]-[sortname]], RuleNoCond(
    NoAnnoList(Op(consname, vars))
  , NoAnnoList(Op(consname, ops))
  ))
  with <reset-counter> "injections"
     ; args := <collect-om-concat(str-sort-with-name)> body
     ; vars := <map(str-sort-to-var)> args
     ; ops := <map(str-sort-to-explication(|lang))> args
     
  str-sort-with-name: s@Sort(name) -> (s, newname)
  with newname := $[t[<next-counter> "injections"]]
  str-sort-with-name: s@IterStarSep(sort, _) -> (s, newname)
  with newname := $[ts[<next-counter> "injections"]]
  
  str-sort-to-var: (_, newname) -> Var(newname)
  
  str-sort-to-explication(|lang): (sort, newname) -> App(<str-sort-to-explication-call(|lang)> sort, Var(newname))
  str-sort-to-explication-call(|lang): Sort(name) -> CallNoArgs(SVar($[explicate-injections-[lang]-[name]]))
  str-sort-to-explication-call(|lang): IterStarSep(sort, _) -> Call(SVar("map"), [<str-sort-to-explication-call(|lang)> sort])
  
rules

  str-sort-to-placeholder-rules(|lang):
    sortname -> RDefNoArgs($[explicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op($[[sortname]-Plhdr], []))
    , NoAnnoList(Op($[[sortname]-Plhdr], []))
    )) 

